---
layout: post
title: Lua脚本语言学习笔记
date: 2013-12-09 19:41
category: "Lua"
---

##1、开始
Lua脚本是一个很轻量级的脚本，也是号称性能最高的脚本，用在很多需要性能的地方，比如：游戏脚本，nginx，wireshark的脚本。
###语法规范
        #注视代码块
        --[[
            print(10)
        --]]
        #取消注释
        ---[[
            print(10)
        --]]
        
###解释器程序
lua [选项参数] [脚本[参数]]
* -e 可以直接在命令喊中输入代码，例如

        $ lua -e "print(math.sin(12))"
 
* -l 用于加载库文件
* -i 在运行完其他命令行参数后进去交互模式。
        
        $ lua -i -l a -e "x=10"

可以定义一个名为"_PROMPT"的全局变量，解释器就会用它的值作为交互模式的命令提示符。

        $ lua -i -e "_PROMPT='June\'s lua>'"
        --->June's lua>

在交互模式中，需要打印任何表达式的值，可以用=开头，并跟随一个表达式，例如：

        June's lua>=math.sin(3)
        
##2、类型与值

Lua中有8中基础类型，函数type可根据一个值返回其类型名称
        
        print(type(print))      --->function
        print(type(type(X)))    --->string
        #永远返回"string" 因为type函数返回一个字符串
        
* nil(空):全局变量第一次赋值前的默认值是nil,将nil赋予一个全局变量等于删除它
* boolean(布尔)：true和false，Lua将值false和nil视为"假"，其他均为"真"
* number(数字)：表示实数，双精度浮点数
* string(字符串)：字符串是不可变的值，不能像C语言中那样直接修改字符串的某个字符，而是应该根据修改要求来创建一个新的字符串
        
        \a:响铃
        \b:退格
        \f：提供表格
        \n:换行
        \r：回车
        \t：水平tab
        \v：垂直tab
        \\反斜杠
        \"双引号
        \'单引号
        
  Lua在运行时提供了数字与字符串的自动转换，如果需要显式地将一个字符串转换成数字，可以使用函数tonumber。若要将一个数字转换成字符串，可以调用函数tostring,或者将该数字与一个空字符串相连接，在Lua5.1中，可以在字符串前放置操作符"#"来获得该字符串的长度。
  
* uerdata(自定义类型)：用于表示一种由应用程序或C语言库所创建的新类型
* function(函数)
* thread(线程)
* table(表)：table.maxn函数，返回一个table的最大正索引数，当对索引的实际类型不是很确定时，可以明确地使用一个显式转换
        
##3、表示式
* 关系操作符：对于table、userdata和函数，Lua是作引用比较的，也就是说，只有当它们引用同一个对象时，才认为它们相等。
* 逻辑操作符：对于操作符and来说，如果它的第一个操作数为假，就返回第一个操作数;不然返回第二个操作数。对于操作符or来说，如果第一个操作数为真，就返回第一个操作数；不然返回第二个操作数。and的优先级高于or
* 字符串连接：".."如果任意一个操作数是数字的话，Lua会将这个数字转换成一个字符串。连接操作符智慧创建一个新的字符串，不会对原操作数进行任何修改。
* 优先级`^`>`not # -(一元)`>`* / %`>`+ -`>`..`>`< > <= >= ~= ==`>`and`>`or`

##4、语句
* 多重赋值并不会比相等价的多条单一变量赋值语句更快，但有时的确会需要多重赋值，例如交换两个变量，收集函数的多个返回值。
* 局部变量和块：局部变量的作用于仅限于申明它们的那个块。一个块是一个控制结构的执行体、或者是一个函数的执行体或者是一个程序块。在交互模式中，每行输入内容自身就形成了一个程序块，可以用do-end显式地界定一个块。"尽可能的使用局部变量！"，访问局部变量比访问全局变量更快。'local foo = foo'创建一个局部变量，并将用全局变量foo的值初始化它。
* 一个申明在循环体中的局部变量的作用于包括了条件测试(5.1新功能)
* 数字型for循环中，3个表达式是在循环开始前一次性求值的，不设置循环上限:（math.huge）
* 泛型for循环通过一个迭代器(iterator)函数来遍历所有值，标准库提供了几种迭代器：

        io.lines:迭代文件中的每行
        pairs:迭代table元素
        ipairs:迭代数组元素
        string.gmatch:迭代字符串中单词
   
* 数字型和泛型for循环：控制变量会被自动申明为for语句的局部变量，并且仅在循环体内可见。不要在循环过程中修改控制变量的值，否则会导致不可预知的效果。

##5、函数

###多重返回值
* 函数调用作为一条单独语句时，Lua会丢弃函数的所有返回值
* 函数作为表达式的一部分来调用时，Lua只保留函数的第一个返回值
* 只有当一个函数调用是一系列（多重赋值，函数调用时传入的实参列表，table的构造式和return语句）表达式中的最后一个元素时，才能获得它的所有返回值
* 可以将一个函数调用放入一对圆括号中，从而迫使它只有一个返回结果
* unpack:接受一个数组作为参数，并从下标1开始返回该数组的所有元素，unpack的一项重要用途体现在"泛型调用(generic call)"机制中。泛型调用机制可以动态地以任何实参来调用任何参数。

###变长参数(variable number of arguments)
参数列表中的3个点表示该函数可接受不同数量的实参。

* string.format:格式化文本函数
* io.write:输出文本函数
* select：必须传入一个固定实参selector（选择开关）和一系列变长参数，如果selector为数字n，那么select返回它的第n个可变实参，否则，selector只能为字符串"#",这样select会返回变长参数的总数。

###具名实参
将所有实参组织到一个table中，并将这个table作为唯一的实参传给函数

##6、深入函数
函数和所有其他值一样都是匿名的，即它们都没有名称。一个函数定义实际就是一条赋值语句，这条语句创建了一种类型为”函数“的值，并将这个值赋予一个变量。

* table.sort:接受两个元素，并返回在有序情况下第一个元素是否应排在第二个元素前

###closure（闭合函数）
若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这个特征称之为"词法域"。

closure是指一个函数及一些列这个函数会访问到”非局部的变量（或upvalue)“，因此若一个closure没有那些会访问的"非局部变量"，那它就是一个传统概念中的"函数"

###尾调用
在Lua中，只有"return<func>(<args>)"这样的调用形式才算是一条”尾调用“，Lua会在调用前对<func>及其参数求值，所以它们可以是任意复杂的表达式。

##7、迭代器与泛型for

###泛型for的语义
泛型for在循环过程内部保存了迭代器函数。实际上它保存着3个值：一个迭代器函数、一个很恒定状态（invariant state）和一个控制变量（control variable）

泛型for的语法如下：

        for<var-list>in<exp-list>do
            <body>
        end
        
其中`<var-list>`是一个或多个变量的列表，以逗号分隔;`<exp-list>`是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器工厂的调用。

for做的第一件事情是对in后面的表达式求值。这些表达式一个返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。初始化之后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环终止

###无状态的迭代器
一种自身不保存任何状态的迭代器，因此，我们可以在多个循环中使用同一个无状态的迭代器，比便创建新的closure开销。

###具有复杂状态的迭代器
通常一个基于closure实现的迭代器会比一个使用table的迭代器更高效，这是因为，首先创建一个closure就比创建一个table更廉价，其次范文"非局部变量"比访问table字段更快。

##8、编译、执行与错误

* loadstring总是在全局环境中编译它的字符串
* Lua将所有独立的程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变长实参。
* assert函数检查其第一个参数是否为true，若为true，则简单返回该参数false就引发一个错误，它的第二个参数是一个可选的信息字符串。
* pcall函数会以一种"保护模式(protected mode)"来调用它的第一个参数，因此pcall可以捕获函数执行中的任何错误。当pcall返回其错误信息时，它已经销毁了调用栈的部分内容，也就是从pcall到错误发生点的这部分调用。
* xpcall：该函数除了接受一个需要被调用的函数之外，还接受第二个参数----一个错误处理函数。当发生错误时，Lua会在调用栈展开前调用错误处理函数。

##9、协同程序（coroutine）

###协同程序基础
一个具有多个协同程序的程序在任意时刻只能运行一个协同程序，并且正在运行的协同程序只会在其显式地要求挂起（suspend)时，它的执行才会停止。

* 在第一次调用resume时，并没有对应的yield在等待她，因此所有传递给resume的额外参数都将视为协同程序主函数的参数。在resume调用返回的内容中，第一个值为true则表示没有错误，而后面所有的值都是对应yield传入的参数。当一个协同程序结束时，它的主函数所返回的值都将作为对应resume的返回值
