---
layout: post
title: 正则表达式(regular expression)笔记
date: 2013-12-02 23:11
category: "regular expression"
---

##一、正则表达式入门
* `^`代表一行的开始
* `$`代表一行的结束
* `.`匹配任意字符的字符组的简便写法，在字符组中，`.`不是元字符

###字符组
* `sep[ea]r[ea]te`匹配seperate separate separete seperete等 
* `-`在字符组内部代表范围，H[1-6]与H[123456]一致，如果出现在字符组开头，它代表的就是一个普通字符
* `?`和`!`通常被当做元字符，挡在字符组中就不是如此

###排除性字符组
* `[^1-6]`匹配除了1到6以外的任何字符

###多选结构
* `|`它的意思是"或"，`Bor|Robert`就是能够同时匹配其中任意一个的正则表达式，在字符组中，它只是一个普通字符.
* 注意:`^From|Subject|Date:*`和`^（From|Subject|Date）:*`匹配结果是不一样的.

###忽略大小写
    egrep的命令行参数"-i"表示进行忽略大小写的匹配，写在正则表达式之前.
    
###单词分界符
前提:egrep支持”元字符序列“

* `\<`和`\>`用来匹配单词分界的位置。`\<cat\>`匹配cat这个单词.`\<cat``cat\>`用来匹配以cat开头和结束的单词.`<``>`本身不是元字符，只有当它们和斜线结合起来的时候。整个序列才具有特殊意义，所以称之为元字符序列.

###可选项元素
* `?` 代表可选项.把它加在一个字符的后面，就表示此处容许出现这个字符，不过它的出现并非匹配成功的必要条件

###其他量词：重复出现
* `+`表示之前紧邻的元素出现一次或多次，
* `*`表示之前紧邻的元素出现任意多次，或者不出现.

###规定重现次数的范围：区间
* 某些本版本的egrep能够使用元字符序列来自定义出现次数的区间：`[a-zA-z]{1,5}`来匹配1到5个字母

###括号及反向引用
括号的两种用途：限制多选项的范围;将若干字符组合为一个单元，受问号或星号之类量词的作用。
反向引用例子：`\<([a-z]+)+\1\>`用来查找连续的重复单词，但egrep吧每行文字都当做一个独立部分来看待，所以如果两个单词在不同行，这个表达式就无法找到.

###神奇的转义
* `\` 作用的元字符会失去特殊意义，成了普通字符
    
###Note:
* egrep会在检查正则表达式之前把每一行的换行符去掉
* 在字符组内部，元字符的定义规则以及它们的意义是不一样的
* 无论列出的字符有多少，字符组只能匹配一个字符。相反，多选项可以匹配任意长度的文本，每个多选项可能匹配的文本都是独立的，多选项没有像字符数组那样的排除功能
* 排除性子附注是表示所有未列出的字符组的简便方法,因此，`[^x]`的意思不是”只有当这个位置不是x时才能匹配“，而是说”匹配一个不等于x的字符"
* 大多数程序设计语言和工具都支持字符数组内部的转义，但是大多数版本的egrep不支持，它们会把反斜线当做字符组内部列出的普通字符

###更多的列子
* 匹配时间：`(1[012]|[1-9]):[0-5][0-9](am|pm)`或`[01]?[0-9]|2[0-3]:[0-5][0-9]`

##二、入门示例扩展
* 在尝试匹配时，正则表达式中的元字符`\1`指向之前匹配的某些文本，匹配成功之后，在接下来的程序中用`$1`来引用同样的文本
* 非捕获型括号`(?:...)`表示只分组，不捕获

###许多流派的正则表达式提供的简记法
* `\b` 在perl中，匹配一个单词的分界符，但是在字符组中，它匹配一个退格符
* `\t` 制表符
* `\n` 换行符
* `\r` 回车符
* `\s` 任何“空白”的字符(例如空格符、制表符等)
* `\S` 除`\s`以外的任何字符
* `\w` `[a-z0-9A-Z]`(在`\w+`中很有用，可以用来匹配一个单词)
* `\W` 除`\w`之外的任何字符，也就是`[^a-zA-Z0-9]`
* `\d` `[0-9]`，即数字
* `\D` 除`\d`外的任何字符，即`[^0-9]`

###使用正则表达式修改文本
* `s/.../.../*`将前面的字符串内容替换为后面的字符串内容。
* `s/.../.../g` `/g`表示全局替换，它告诉`s/.../.../`在第一次替换完成之后继续搜索更多的匹配文本，进行更多的替换.
* `s/\bJeff\b/Jeff/i`搜索"Jeff"这个词是不区分大小写的。而所有匹配的字符串都会被替换为"Jeff"，第一个字母是大写，其他为小写.`/i`对replacement的文本没有影响
* `s/(\.\d\d[1-9]?)\d*/$1/`保留小数点后梁如数字，如果第三位不为0,也需要保留
* `/^\s*$/`检测空格行
* `/^Subject:(.*)/i`不区分大小写匹配Subject，将之后的内容捕获
* `\S+`匹配第一个空白之前的文本（或者目标文本末尾之前的所有字符）
* `s/^/|>/`在开头加入`|>`

###用环视功能为数值添加逗号
环视结构不匹配任何字符，只匹配文本中的特定位置，环视不会占用字符

* 顺序环视：顺序环视顺序（从左到右）查看文本，尝试匹配子表达式，如果能够匹配，就返回匹配成功信息。
* `(?=...)`:肯定顺序环视
* `(?!...)`:否定顺序环视
* 逆序环视：它逆序（从右到左）查看文本
* `(?<=...)`:肯定逆序环视
* `(?<!...)`:否定逆序环视

####顺序环视示例
* `(?=Jeffey)Jeff`它只能匹配"Jerrfrey"这个单词中的"Jeff"，它与`Jeff(?=rey)`等价
* `s/\bJeff(?=s\b)/Jeff'/g`
* `s/(?<=\bJeff)(?=s\b)/'/g`匹配了我们希望插入撇号的位置。在这种情况下，我们并没有“替换”任何字符，而只是插入了一个撇号。且与`s/(?=s\b)(?<=\bJeff)/'/g`等价。无论是先检查左边，再检查右边，还是相反，关键是，在同一位置两边的检测必须都能成功，整个匹配才算成功。
* `s/(?<=\d)(?=(\d\d\d)+$`/,/g 在2238748274数字中每隔3个数字加入","即2,238,748,274，PS:若不捕获，可以用`(?:\d\d\d)`
*`(?<!\w)(?=\w)` 表示单词起始分界符
*`(?<=\w)(?!\w)` 表示单词结束分界符
* `s/(\d)(?=(\d\d\d)+(?!\d)/$1,/g`不通过你逆序环视添加逗号

####Note
一次迭代完成时，下一次的迭代会从上一次匹配的终点开始尝试。使用环视的意义在于，检查某个位置，但检查时匹配的字符并不算在（最终）“匹配的字符串”内。

##三、正则表达式的特性和流派概览
在某种特定的宿主语言或工具软件中使用正则表达式时，主要有三个问题值得注意：

* 支持的元字符，以及这些元字符的意义。这通常成为正则表达式的“流派(flavor)”
* 正则表达式与语言或工具的“交互”(interface)方式。譬如如何进行正则表达式操作，容许进行哪些操作，以及这些操作的目标文本类型。
* 正则表达式引擎如何将表达式应用到文本。语言或工具的设计者实现正则表达式的方法，对正则表达式能够取得的结果有重要的影响。

一般来说，程序设计语言有3中处理正则表达式的方式：级城市(integrated)、程序是(procedural)和面向对象式(object-oriented)。在第一种方式中，正则表达式是直接内建在语言中的，Perl就是如此。但是在其他两种方式中，正则表达式不属于语言的低级语法。相反，普通的函数接受普通的字符串，把它们作为正则表达式进行处理。由不太能够的函数进行不通的、关系到一个或多个正则表达式的操作。大多数语言（不包括perl)采用的都是这两种方式之一，包括Java、.NET、Tcl、Python、PHP、Emacs、lisp和Ruby。

###正则模式和匹配模式
* 不区分大小写的匹配模式 i
* 宽松排列和注释模式：忽略字符组外部的所有空白字符 x
* 点号通配模式(dot-match-all match mode，也叫"单行模式") s
* 增强的行锚点模式(Enhanced line-anchor match mode,也叫"多行文本模式") m
* 文字文本模式：文字文本模式几乎不能识别任何正则表达式元字符

###常见的元字符和特性

####字符表示法：
* `\a` 警报
* `\e` Escape字符,通常对应ASCII中的`<ESC>`字符
* `\v` 垂直制表符

####八进制转义\num
支持八进制转义方式通常容许以2到3位数字表示该值所代表的字节或字符。八进制转义可以很方便地在正则表达式中插入平时难以输入的字符

####十六进制及Unicode转义:\xnum、\x{num}、\unum、\Unum

####几乎能匹配任何字符的元字符：点号
在某些工具软件中，点号用来缩略表示可以匹配任何字符的字符组，而在其他工具中，点号能匹配除了换行符之外的任何字符，关于点号，需要注意的有：
* 匹配模式会改变点号的匹配规则
* POSIX规定，点号不能匹配NULL（值为0的字符），尽管大多数脚本语言容许文本中出现NULL（而且可以用点号来匹配）

####POSIX"字符组"方括号表示法
我们通常所说的字符组，在POSIX标准中成为方括号表达式(bracket expression)。POSIX中的属于“字符组”指的是在方括号表达式内部使用的一种特殊功能。

POSIX字符组的详细列表根据locale的变化而变化，但是下面这些通常都能支持：

* `[:alnum:]` 字母字符和数字字符
* `[:alpha:]` 字母
* `[:blank:]` 空格和制表符
* `[:cntrl:]` 控制字符
* `[:digit:]` 数字
* `[:graph:]` 非空字符（即空白字符，控制字符之外的字符）
* `[:lower:]` 小写字母
* `[:print:]` 类似`[:graph:]`,但是包含空白字符
* `[:punct:]` 标点符号
* `[:space:]` 所有的空白字符（`[:blank:]`、换行符、回车符及其他）
* `[:upper:]` 大写字母
* `[:xdigit:]` 十六进制中容许出现的数字（例如0-9a-fA-F）

####锚点及其他“零长度断言”
* 行/字符串的其实位置`^`、`\A` 脱字符`^`匹配需要搜索的文本的起始位置，如果使用了增强的行锚点匹配模式，它还能匹配每个换行符之后的位置。如果可以使用，则无论在什么匹配模式下，`\A`总是能够匹配待搜索文本的起始位置。
* 行/字符串的结束位置：`$`、`\z`和`\Z`.`$`最常见的意思是匹配目标字符串的末尾，也可以匹配整个字符串末尾的换行符之前的位置。匹配模式可以改变`$`的意义，匹配字符串中的任何换行符。如果支持，`\Z`通常表示“未指定任何模式下”`$`匹配的字符，通常是字符串的末尾位置，或者是在字符串末尾的换行符之前的位置。作为补充，`\z`只匹配字符串的末尾，而不考虑任何换行符
* 匹配的起始位置（或者是上一次匹配的结束位置）：`\G`
* 环视:环视结构中，大多数实现方式都限制了逆序环视中的表达式的长度（但是顺序环视则没有限制），在Perl和Python中。逆序环视只能匹配固定长度的文本。

###注释和模式修饰符

####模式修饰符：（?modifier),例如(?i)和(?-i)
`(?i)` 启用不区分大小写的匹配，而`(?-i)`会停用此功能。例`<B>(?i)very(?-i)</B>`。除Python之外。大多数实现方式中，`(?i)`的作用范围都只限于括号内部（也就是说，在闭括号之后就失效），即`<B>(?:(?i)very)</B>`

####模式作用范围：(?modifier:...)，例如(?i:...)
`(?i:...)`表示模式修饰符的作用范围只有在括号内有效。

####注释：(?#...)和#...

####文字文本范围:\Q...\E
它会消除其中除了\E之外所有元字符的特殊含义（如果没有\E，就会一直作用到正则表达式末端）。其中的所有字符都会被当成普通文字文本来对待。如果在构建正则表达式时包含变量，次功能就非常有用。

###分组，捕获，条件判断和控制

####捕获/分组括号：(...)和\1，\2，...
捕获型括号的编号是按开括号出现的次序，从左到右计算的。如果提供了反向引用，则这些括号内的子表达式匹配的文本可以在表达式的后面部分用`\1`、`\2`来引用。

####仅用于分组的括号：`(?:...)`
仅用于分组的括号`(?:...)`不能用来提取文本，而只能用来规定多选结构或者两次的作用对象。

####命名捕获：(?<name>...)

####固化分组：(?>...)
一旦括号内的子表达式匹配之后，匹配的内容就固定下来（固化(atomic)下来无法改变），在接下来的匹配过程中不会变化，除非整个固化分组的括号都被弃用，在外部回溯中重新应用。

####多选结构：...|...|...
多选结构的优先级很低，所以`this and|or that`的匹配等价于`(this and)|(or that)`

####条件判断：(?if then |else)

##四、表达式的匹配原理

正则引擎可以粗略地分为3类：

* DFA(符合或不符合POSIX标准的都属于此类）
* 传统型NFA
* POSIX NFA

###匹配的基础

* 优先选择最左端的匹配结果，如用`fat|cat|belly|your`来匹配字符串`The dragging belly indicates that your cat is too fat`的结果是`beely`
* 标准的匹配量词(`*`、`+`、`?`)和`{m,n}`是匹配优先的。

###引擎构造

正则引擎中的零件分为几类————文字字符(literal characters)、量词（qualifiers）、字符组（character classes）、括号，等等。

锚点可以分为两类：简单锚点（^、$、\G、\b、）和复杂锚点(例如顺序环视和逆序环视）。简单锚点之所以得名，就在于它们只是检查目标字符串中的特定位置的情况，或者是比较两个相邻的字符。相反，复杂锚点能包含任意复杂的子表达式，所以它们也可以任意复杂。

###表达式主导与文本主导

* NFA引擎：表达式主导
* DFA引擎：文本主导

###比较NFA与DFA

DFA特性:

* DFA匹配很迅速
* DFA匹配很一致
* 谈论DFA匹配很恼人

####回溯
NFA引擎最重要的性质是，它会依次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择的时候，它会选择其一，同时记住另一个，以备稍后可能的需要。

回溯的两个要点：

* 如果需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”。

* 距离当前最近存储的选项就是当本地失败强制回溯时返回的。使用的原则是LIFO（last in first out,后进先出）。

####匹配优先

匹配时只从自身出发，匹配尽可能多的内容，只有在全局匹配需要的情况下才会“被迫”交换一些字符。

####忽略匹配优先
与匹配优先相反

###占有优先量词和固化分组
* 用(?>...)实现固化分组：如果匹配进行到此结构之后（也就是，进行到闭括号之后），那么此结构体中的所有备用状态都会被放弃。也就是说，在固化分组匹配结束时，它已经匹配的文本已经固化为一个单元，只能作为整体而保留或放弃。

###Note
匹配优先和忽略优先都不会影响需要检测路径的本身，而智慧影响检测的顺序。如果不能匹配，无论是按照匹配优先还是忽略优先的顺序，最终每条路径都会被测试。然而，固化分组与它们截然不同，因为固化分组会放弃某些可能的路径。更具具体情况的不同，放弃备用状态可能会导致不同的结果：
* 毫无影响
* 导致匹配失败
* 改变匹配结果
* 加快报告匹配失败的速度

###占用优先量词，`?+`、`*+`、`++`和`{m,n}+`
占用优先量词与匹配优先量词很相似，只是它们从来不交还已经匹配的字符。

###环视中的回溯
只要环视结构的匹配尝试结束。它就不会留下任何备用状态。任何备用状态和例子中肯定环视成功时的情况一样，都会被放弃。

###多选结构
传统型NFA引擎，遇到多选结构时，这种引擎会按照从左到右的顺序检查表达式中的多选分支，NFA和POSIX NFA中有匹配优先的多选结构，它们总是匹配所有多选分支中能匹配最多文本的那个。

###NFA、DFA和POSIX
* 最左最长规则：如果传动装置在文本的某个特定位置启动DFA引擎，而在此位置又有一个或多个可能的匹配，DFA就会选择这些可能中最长的
* POSIX和最左最长规则：POSIX标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配。

###NFA与DFA的比较

* 在预编译阶段（pre-use compile)的区别：在使用正则表达式搜索之前，两种引擎都会变异表达式，得到一套内化形式，适应各自的匹配算法。NFA的编译过程通常要快一些，需要的内存也更少一些。传统型NFA和POSIX NFA之间并没有实质的差别
* 匹配速度的差别：对于“正常”情况下的简单文本匹配测试，两种引擎的速度差不多。一般来说，DFA的速度与正则表达式无关，而NFA中两者直接相关。
* 匹配结果的差别： DFA（或则POSIX NFA）返回最左边的最长的匹配文本。传统型NFAK额能返回同样的结果，当然也可能是别的文本。
* 能力的差异：NFA引擎能提供一些DFA不支持的功能，例如：
    1. 捕获由括号内的子表达式匹配的文本
    2. 环视，以及其他复杂的零长度确认
    3. 非匹配优先的量词，以及有序的多选结构
    4. 占有优先量词和固化分组

##五、正则表达式使用技巧

###正则表达式的平衡法则
* 只匹配期望的文本，排除不期望的文本
* 必须易于控制和理解
* 如果使用NFA引擎，必须保证效率(如果能偶匹配，必须很快地返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失效)。

###若干简单的例子：

####匹配连续行
 
        SRC= if else hello \
             very nice" 

`^w+=.*(\\\n.*)*`--->不能匹配

`^w+=[^\n\\]*(\\\n[^\n\\]*)*`---> 不允许\出现在字符串中

`^w+=([^\n\\]|\\.)*`--->OK

####匹配IP地址

`^\d+\.\d+\.\d+\.\d+$` --->会匹配1234.5678.12312.214214

`^\d{1-3}+\.\d{1-3}+\.\d{1-3}+\.\d{1-3}+$`或

`^\d\d?\d?+\.\d\d?\d?+\.\d\d?\d?+\.\d\d?\d?+$` --->会匹配299.299.299.299等

`[01]?\d\d?|2[0-4]\d|25[0-5]` --->0-255

`^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$`

####处理文件名
* 将\usr\local\bin\gcc变成gcc `s/^.*\\//`
* 所在路径和文件名 `^(.*)/(.*)$`

####匹配对称的括号
处理单层嵌套的正则表达式是：`\[^()]*(\([^()]*\)[^()]*)*\)`

####匹配分隔符之间的文本
`*(\\.|[^\\*]*"`

####去除文本首尾的空白字符
`s/^\s+//`

`s/\s+$//`

##其他
* [Vim中的正则表达式](http://blog.csdn.net/june_water/article/details/17101293)
* [grep与正则表达式](http://blog.csdn.net/june_water/article/details/17101633)
* [C/C++正则表达式主要函数分析](http://blog.csdn.net/june_water/article/details/17102395)
        
        $ gcc regex.c -o regex
        $ ./regex "http:\/\/www\..*\.com" "https://www.taobao.com"
        # ErrMsg: No match 
        $ ./regex "https:\/\/www\..*\.com" "https://www.taobao.com"
        # https://www.taobao.com matches https:\/\/www\..*\.com
        
 
